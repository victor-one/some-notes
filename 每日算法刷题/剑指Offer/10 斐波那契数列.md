# 10 斐波那契数列

## 题目内容

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例** 1：

```
输入：n = 2
输出：1
```

**示例2：**

```
输入：n = 5
输出：5
```

**提示**：

`0 <= n <= 100`

## 解题方法

**算法流程：**

1. 初始化`a`和`b`分别为初始数字0和1；
2. 由于f(n) = f(n-1) + f(n-2)，此时存在负数情况，为了解决此情况，将公式转化为f(n+1) = f(n) + f(n-1)：
   1. 进行一个n次的for循环，每次循环a的值变为原来的b，b的值变为原来的a与b之和
3. 返回最后得到的a%1000000007

**复杂度分析：**

* **时间复杂度**为O(N)
* **空间复杂度**为O(1)

**代码：**

```python
class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for i in range(n):
            a, b = b, a + b
        return a % 1000000007
```

## 总结

老实说，看到这道题目，第一反应就是递归了，啊，这题我会，简单，递归嘛，然后不出意外，超时了。毕竟这道题目用递归的话，时间复杂度是O(2^N)。( ╯□╰ )

一开始没有想到将表达式进行一下转换表达，所以在初始的代码中进行了一个if条件筛选，后面看解析才发现其实不用。

如果上述代码不能理解的话，补充一个我的初始版代码吧。

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        a, b = 0, 1
        for i in range(n-1):
            sum = a + b
            a = b
            b = sum
        return b % 1000000007
```


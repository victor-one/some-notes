# Vue 面试题

## 1. 组件通信

### 回答

我们按照场景进行讲解吧，一般来说我们常见的场景有四种：父子组件通信、爷孙组件通信、兄弟组件通信、全局组件通信。

**父子组件通信**：

1. **props**，父组件通过props向子组件传值，在使用的时候需要显式声明；
2. **emit**，子组件通过自定义事件向父组件中传值；
3. **ref**，父组件通过 ref 对子组件添加标记，从而获取子组件中的数据，需要注意的是在`setup`中**需要使用`defineExpose`将数据暴露出来**才可以获得；
4. **\$attrs**，父组件通过 \$attrs 进行属性继承，从而进行数据传递，需要注意的是 \$attrs 默认是继承在最外面的元素上的，如果想绑定在内部，需要禁用属性继承，手动使用`v-bind`绑定`$attrs`；
5. **\$parent**，写选项式API的时候使用，但是不推荐，考虑到组件的复用性。

**兄弟组件通信：**

1. **\$parent/\$root**，利用父组件进行通信；
2. 借助**全局组件通信**方式：
   1. **EventBus**：需要借助第三方插件 mitt 等才可以实现；
   2. **全局状态管理工具 vuex/Pinia**。

**爷孙组件通信**：

1. 同样可以采用全局组件通信方式；
2. **provide/inject**。

## 2. v-if 和 v-for 哪个优先级更高

### 回答

1. 在实践中不应该把 v-if 和 v-for 放在一起使用；
2. 在 vue3 中 **v-if 的优先级高于 v-for**，因此在 v-if 执行的时候，它**调用的变量还不存在，因此会导致异常**；
3. 在实际使用中有两种情况可能这样做：
   1. 过滤列表中的项目，这个时候应该先**定义一个计算属性**，在计算属性中返回过滤后的列表，也可以采用**在外面包一层`<template>`**，然后再在上面使用 v-for ，里面使用 v-if 进行判断。
   2. 避免渲染本来应该被隐藏的项目，这个时候可以**在外面包一层`<template>`**，在上面使用 v-if 进行判断，然后再进行 v-for 渲染。
4. 在 vue3 的**文档中明确声明了不要将两者同时用在同一个元素上**。

## 3. 简述 Vue 的生命周期以及每个阶段做的事

### 回答

1. 每个vue组件实例在被创建后会经过一系列的初始化步骤，在这个过程中会运行生命周期钩子函数**用于在特定阶段添加代码**。
2. vue3 中**一共有8个生命周期**，分别**对应着组件的四个阶段**：创建前后（初始化选项式 api）、挂载前后、更新前后、销毁前后。
3. 除了这8个生命周期之外，**还存在着一些特殊场景下的生命周期**：如在`<KeepAlive>`场景下使用的`onActivated()`和`onDeactivated()`，这两个周期分别对应在`<KeepActive>`中**缓存的组件激活和停用的时候**调用。`onErrorCaptured()`，这个生命周期钩子函数主要在**捕获了子组件的错误时**调用。
4. 另外在vue3中还**增加了三个新的生命周期钩子**，`onRenderTracked`和`onRenderTriggered`这两个钩子**仅可用于开发模式**中，分别在**响应式依赖被收集的时候和响应式依赖变更的时候**使用。`onServerPrefetch`这个钩子**仅可在SSR下**使用，在**组件实例在服务器上被渲染之前**调用。

![组件生命周期图示](https://cn.vuejs.org/assets/lifecycle.16e4c08e.png)

### 补充问题：setup 和 created 的问题

**setup 早于其他所有选项之前执行**，且 setup 中**没有 beforeCreate 和 created**，这是因为**在 setup 中已经做完了创建实例的这一步**。

## 4. 双向绑定的使用和原理

### 回答：

1. vue 中双向绑定即 `v-model`，可以绑定一个响应式数据到视图，同时视图中变化能够改变该值；
2. `v-model` 是一个语法糖，**相当于`:value`和`@input`**。
3. 通常**在表单元素中**使用`v-model`，也可以**在自定义组件上**使用，表示某个值的输入输出控制。
4. 在自定义组件上使用的时候，相当于`:modelValue`和`@update:modelValue`，对应在对应组件内部需要将原生的`input`元素的`value`属性绑定到`modelValue`prop，同时输入新的值的时候在`input`元素上触发`update:modelValue`事件。也可以**使用`v-model`绑定指定的prop**，可以创建多个绑定。
5. 在使用`v-model`的时候，还**可以结合修饰符**来使用，比如：`.lazy`可以将数据更新改为在`change`事件后、`.number`可以将用户输入自动转化为数字、`.trim`可以默认去除用户输入内容两端的空格。

## 5. vue 中如何扩展一个组件

### 回答

1. 在 vue3 中**对组件逻辑的扩展**，**推荐使用的是组合式api的方式**，在**选项式api中则可以使用 mixins、extends** 来进行实现。对于**内容的扩展**则可以使用 **slots** 来进行实现。
2. **mixins** 则是通过选项**接收一个 mixin 对象数组**，需要注意的是，如果组件和 mixin 里面同时有相同数据，**组件中的数据优先级更高**。mixins 有**两种混入方式**：**全局混入**`Vue.mixin()`和**局部混入**`mixins:[]`，**局部混入仅作用于当前组件**。
3. **extends** 和 mixins 实现基本相同，通过extends 指定的组件将会当作第一个 mixins 处理（**优先级更高**）。但是目标不同，**mixins 选项基本用于组合功能，extends 更关注继承关系**。
4. 由于混入数据的方式**不能明确判断数据来源**且**可能存在变量命名冲突**，因此Vue3引入**组合式api**，使用 export 将需要的逻辑函数导出，再在组件中通过 import 引入。
5. **插槽 slots** 主要用于vue组件中的内容分发，也可以用于组件扩展。

### 补充：Vue.extend 方法能否用来做组件扩展

这是在 vue2 中用来写组件的一种方式，但是在vue3中已经废除了，不可以用来做组件扩展。

## 6. 子组件可以直接改变父组件的数据吗

### 回答

1. vue 中**遵循单向数据原则**，父级 prop 的更新会向下流动到子组件中，但反过来不行。
2. 如果实际开发中需要利用 prop 来向子组件中传递一个初始值，需要在子组件中**定义一个本地 data，将这个 prop 作为其初始值**。如果需要对 prop 作为初始值之后**进行转换，需要定义一个计算属性**。
3. 如果想要改变父组件属性，**应该定义一个 emit 事件从而让父组件来进行修改**。

## 7. Vue 中如何做权限管理，如何做控制到按钮级别的权限

### 回答

1. 权限管理一般来说分为两种，一种是**页面权限**管理，一种是**按钮权限**管理；
2. 具体的实现分为两种方案，分别为**前端方案和后端方案**，两者的区别是**路由信息的存放位置**：
   * 前端方案将**所有的路由信息在前端进行配置**，然后通过路由守卫来要求用户登录，用户登录后**根据用户角色过滤出路由表**，最后**通过`addRoutes`动态添加路由**；
   * 后端方案则是**将路由信息存储在数据库**中，用户登录的时候根据其角色查询其能访问到的所有页面路由信息，**将信息返回到前端**，最后通过`addRoutes`动态添加路由；
   * **按钮权限控制**一般来说会**通过一个自定义指令`v-permission`**来实现，将**按钮要求的角色通过值传递给 `v-premission` 指令**，在指令的`mounted`钩子中**判断当前角色是否与按钮存在交集**，有的话就保留按钮，没有的话就移除按钮。
3. 纯前端方案的优点是实现简单，不需要额外的权限管理页面，但是难维护，每次有新的页面和角色需求的时候就需要重新打包部署页面；服务端方案则不存在这个问题，每次登录的时候获得的都是最新的路由信息。

### 补充：v-permission 的实现

[v-permission实现](https://juejin.cn/post/7018193440609402894)

### 补充：类似 Tabs 这类组件能否使用 v-permission 实现按钮权限控制

不可以，这是因为`v-permission`指令的**实现原理是通过对 DOM 元素进行操作移除**从而实现的，这是 **DOM 级别的删除**，**不可以在组件层级别进行实现**。如果要实现组件的控制可以**使用`v-if`来进行实现**。

### 补充：服务端返回的路由信息如何添加到路由中

建立一个**哈希表来进行组件名与对应组件的映射**，在获取到服务端的路由信息后。遍历路由信息，将其中的 component 替换为哈希表中对应映射的组件。

```javascript
// 前端组件名和组件映射表
const map = {
  //xx: require('@/views/xx.vue').default // 同步的⽅式
  xx: () => import('@/views/xx.vue') // 异步的⽅式
}
// 服务端返回的asyncRoutes
const asyncRoutes = [
  { path: '/xx', component: 'xx',... }
]
// 遍历asyncRoutes，将component替换为map[component]
function mapComponent(asyncRoutes) {
  asyncRoutes.forEach(route => {
    route.component = map[route.component];
    if(route.children) {
      route.children.map(child => mapComponent(child))
    }
	})
}
mapComponent(asyncRoutes)
```

## 8. 对 Vue 响应式的理解

### 回答

1. 数据响应式指的是**数据变化能够被检测并能针对变化做出响应**的一种机制；
2. 在 Vue 中利用数据响应式结合虚拟DOM和 diff 算法，可以使得开发人员**只需要关注数据层面的逻辑，而不用接触繁琐的DOM操作**，从而大大提升开发效率；
3. 在Vue2中的数据式响应会根据数据类型的不同来做不同的处理，对于**对象使用`Object.defineProperty()`方式定义数据拦截；如果是数组则通过覆盖数组对象原型的7个变更方法**。缺点是：
   1. 初始化的时候**需要递归**，会造成性能损失；
   2. 新增或删除属性需要使用`Vue.set/delete`这种**特殊的api**才能够生效；
   3. 对于 ES6 种**新产生的Map、Set这些数据结构不支持**。
4.  Vue3中的数据响应式是**采用 `Proxy`来创建响应式对象**，仅将**`getter/setter`用于 ref**。这样的好处是不需要特殊api且初始化性能获得改善。

### 补充：响应式的具体实现流程

1. JS 中无法追踪局部变量的读写，但是可以追踪对象属性的读写，因此就可以将数据转化为响应式对象从而进行追踪；
2. 对于 **reactive 通过 Proxy 来创建响应式对象**，**ref 则使用 getter/setter 来实现**。在对象的内部的 get 和 set 中分别使用了 **track 和 trigger 用于追踪副作用**。
3. track 内部会检查当前是否有正在运行的副作用，如果有，会查找一个存储了所有追踪了该属性的订阅者的Set，然后将当前副作用作为新的订阅者添加到 Set 中。trigger 中会查找所有订阅的副作用并执行。

**伪代码实现**

```js
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      trigger(target, key)
    }
  })
}

function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value')
      return value
    },
    set value(newValue) {
      value = newValue
      trigger(refObject, 'value')
    }
  }
  return refObject
}

let activeEffect

function track(target, key) {
  if (activeEffect) {
    const effects = getSubscribersForProperty(target, key)
    effects.add(activeEffect)
  }
}

function trigger(target, key) {
  const effects = getSubscribersForProperty(target, key)
  effects.forEach((effect) => effect())
}
```

## 9. 说说对虚拟 DOM 的理解

### 回答

1. 虚拟 DOM 就是一个虚拟的 DOM 对象，他的**本质上是一个 JS 对象**，只不过它里面定义了不同的属性用来描述视图结构；

2. 通过引入虚拟DOM有如下好处：

   **将真实元素节点抽象为vnode，从而有效减少操作dom的次数，从而提高程序性能**

   * 一个真实的元素上有许多的内容，如果直接对其进行diff操作或进行clone操作会对一些没必要的内容操作。如果将这些操作转移到 JS 对象上，就会变得简单。
   * 频繁的DOM操作会引起页面的重绘和回流，通过抽象vnode进行中间处理可以有效减少直接操作DOM的次数，从而减少页面重绘与回流。

   **方便实现跨平台**

   * 同一个vnode节点可以在不同平台上渲染成对应的内容；
   * Vue3 允许开发者基于vnode实现自定义渲染器（renderer），从而针对不同平台渲染。

3. vdom 的生成过程是：开发者为组件编写**模板**（template），模板被编译器（compiler）**编译**为渲染函数，之后再挂载（mount）过程中调用**render函数**，返回虚拟DOM对象，虚拟DOM在 **patch 过程中**进一步转化为 **DOM**。

   ![image-20220209153820845](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80b653050433436da876459a26ab5a65~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

4. **挂载过程结束**后，vue程序**进入更新流程**。如果响应式数据发生改变引起组件**重新render**，此时**生成新的vdom**，与上一次的渲染结果**diff得到变化的地方**，从而**转换为最小量的dom操作**，更新视图。

## 10. diff 算法

### 回答

1. Vue 中的 diff 算法被称为 **patching 算法**，虚拟DOM想要转化为真实DOM就需要通过patch方法进行转换。
2. 在 Vue1 中**每个依赖都有对应的更新函数**，因此**不需要虚拟DOM和patching算法**，但这样**粒度过细**就导致Vue1无法承载大型应用；因此在Vue2中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，此时就需要引入patching算法从而**精准找到变化位置并更新**。
3. Vue中 diff 执行是在组件内**响应式数据变更触发实例执行其更新函数**的时候，更新函数会再次执行render函数获得最新的虚拟DOM，然后执行patch函数，对比新旧虚拟DOM获取变化的地方，将其转化为对应DOM；
4. patch过程是一个**递归的过程**，遵循**深度优先、同层比较**的策略。其过程如下：
   1. 判断**两个节点是否为同类节点**，不同则删除重新创建；
   2. 如果都是**文本则更新文本内容**；
   3. 如果都是**元素节点则递归更新子元素**，同时**更新元素属性**；
   4. 更新子节点的时候又分为几种情况：
      1. 新的节点是文本，旧节点是数组则清空数组并设置文本；
      2. 新的节点是文本，旧节点是文本则更新文本；
      3. 新的节点是数组，旧节点是文本则清空文本并创建新子节点数组中的子元素；
      4. 新的节点是数组，旧节点也是数组，比较两组子节点，更新细节
5. Vue3 中引入的更新策略：**编译期优化patchFlags、block**等

## 11. Vue3 的新特性

### 回答

1. 在**api方面**有这样几个特性：**组合式api**、**set up语法糖**、Teleport传送门、Fragments、**Emits**、自定义渲染器、SFC CSS变量、Suspense
2. 另外在**框架层面**上更快（**优化了虚拟DOM**、**对编译器优化**、**基于Proxy的响应式系统**）、更小（**tree-sharking优化**）、更容易维护（**TS + 模块化**）、更容易扩展（**独立的响应化模块**、**自定义渲染器**）

## 12. 怎么定义动态路由？怎么获取传过来的动态参数

### 回答

1. 当我们需要**将给定匹配模式的路由映射到同一个组件**上的时候，我们就需要使用动态路由；
2. 比如说有一个`User`组件，我们需要对所有用户渲染，但是用户id不同，此时可以使用**路径参数**来实现，路径参数用`:`表示；
3. 对于组件参数的获取**使用`this.$route.params`来获取**（对于组合式api需要使用`useRoute()`来获取），可以设置多个路径参数；
4. 此外`$route`对象还公布了其他信息，如`$route.query`、`$route.hash`等

### 补充：如何响应动态路由参数的变化

1. 由于**复用相同的组件实例**，因此组件的**生命周期钩子不会被调用**；
2. 要对参数的变化做出响应的话，可以使用 **watch** 对`$route`对象上的属性进行监听；
3. 也可以使用`beforeRouteUpdate`导航守卫，它可以取消导航

### 补充：如何处理404 Not Found路由

1. 常规匹配只能匹配 url 片段之间的字符，用 `/` 来进行分隔。如果想要匹配任意路径可以使用**自定义路径参数表达式**，在路径参数后面的括号中加入**正则**；
2. 比如可以使用`path: '/:pathMatch(.*)*'`，此时，`pathMatch`参数就被标记为可选可重复的了。



## 13. 从0写一个vue路由的思路

### 回答

1. vue路由的核心功能就是要**实现页面跳转内容改变同时不刷新**，同时路由还需要以插件的形式存在；
2. 首先需要定义一个`createRouter`函数，这个函数的作用是用来**创建路由实例**，实例的内部需要做几件事：
   1. **保存用户的配置**；
   2. **监听 hash或者 popstate 事件**；
   3. 在回调函数中**根据 path 匹配对应的路由**
3. 将 **router 定义为一个vue插件**，即实现 install 方法，在这个插件的内部做两件事：
   1. 实现**两个全局组件**：**router-link 和 router-view**，分别用于实现页面的跳转和页面内容的显示；
   2. 还需要定义**两个全局变量**：`$route`和`$router`，使得组件的内部可以访问当前路由与路由实例。

## 14. key 的作用

### 回答

1. key 的作用主要是为了**更加高效的更新虚拟DOM**；
2. 在patch的过程中，key是**用于判断两个节点是否为相同节点**的重要指标，如果**不定义key**的话，就会判断两个节点是同一个节点，这就会**导致频繁的元素更新**，从而影响性能；
3. 在实际使用中，当**渲染一组列表**的时候**必须设置 key**，且 key 必须是唯一标识。一般来说应该**避免使用数组索引来作为key**，因为数组的元素顺序变动可能会带来一些BUG；Vue 中在**使用相同标签元素过渡切换**的时候，也**需要设置 key**，这是为了区分元素，否则Vue 会替换属性值而不触发过渡效果；
4. Vue **判断两个节点是否相同**主要依靠**两者的key 和元素类型**，如果不设置key，就会认为是相同节点，因此会去做更新操作，造成大量的 DOM 更新。

**辅助记忆**

使用 key

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6750831c024116bcac3ece9497b597~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

不使用key

![image-20220214110059028](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d393bc0c4a8946a9a20973b64633852f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

设置了key后会从两端查找，然后找到异常节点

## 15. nextTick 的使用和原理

1. nextTick 是**等待下一次 DOM 更新刷新的工具方法**。
2. 在Vue中存在着一个**异步更新策略**，如果数据发生变化，Vue不会立刻更新DOM，而是开启一个队列，将组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这个策略就导致对数据的修改**不会立刻体现在DOM上**，如果想要**获取DOM更新后的状态**，就需要**使用nextTick**。
3. 开发的时候会有两个场景使用DOM：
   1. **created**中想要获取DOM的时候；
   2. **响应式数据变化后**获取DOM更新后的状态。
4. `nextTick()`可以在状态改变后**立即使用**，以等待 DOM 更新完成。也可以**传递一个回调函数**作为参数或者 **await 返回的 Promise**。
5. 在Vue中之所以 nextTick 能让我们看到 DOM 更新后的结果，是因为我们传入的callback 会**被添加到队列刷新函数的后面**，这样等队列内部的更新函数都执行完，所有的DOM操作也就结束了，此时callback自然能获取到更新的DOM值。

## 16. watch 和 computed 的区别以及选择

### 回答

1. computed 是**计算属性**，它可以利用组件数据**生成一个响应式数据**，最常见的使用方式是设置一个函数，返回计算之后的结果，**computed 和 methods 的差异**是 computed **具有缓存性**，如果**依赖不发生改变就不会重新计算**。watch 是**侦听器**，他可以**侦测某个响应式数据的变化并执行副作用**，最常见的方法是传递一个函数执行副作用，watch **没有返回值**，但是**可以执行异步操作等复杂的逻辑**。
2. 在实际应用中，computed一般用于**简化行内模板中的复杂表达式**。watch 一般用于在状态改变后**执行一些额外的DOM操作或异步操作**。判断选择哪个的时候，首先看**是否需要派生出新的值**，**能用计算属性实现的首选计算属性**。
3. **计算属性**可以**传递对象**，此时**既可以读也可以写**。watch可以传递对象，并在里面设置deep、immediate等选项。
4. 在Vue3 中 watch 选项发生了一些变化，**不能再侦测点操作符以外的字符串形式的表达式**；reactivity API 中**新出现了 watch、watchEffect 可以完全替代目前的watch选项**。

### 补充：watch会不会立即执行

watch 是**不会立即执行**的，因为默认是**懒执行**的，如果想要立即执行的话，需要以一个**对象来声明侦听器**，在对象中设置 `immediate: true`来强制回调函数立即执行。

同样 watch 默认的是浅层侦听，如果想要深层监听，需要设置 `deep: true`。

### 补充：watch 和 watchEffect 的差异

1. watch 和 watchEffect **都能够响应式的执行有副作用的回调**。它们的区别主要在追踪响应式依赖的方式上：
   1. watch **只追踪明确侦听的数据源**，不会追踪在回调中访问到的东西。且**仅在数据源确实发生改变的时候才会触发回调**。watch 会**避免在发生副作用时追踪依赖**。因此**可以精确控制回调函数的触发时机**。
   2. watchEffect **会在副作用发生期间追踪依赖**。且在同步执行的过程中会**自动追踪所有能访问到的响应式属性**。这样代码更加简洁，但有时**响应式依赖关系会不明确**。

## 17. Vue 子组件和父组件创建和挂载顺序

### 回答

1. 组件的**创建**是一个**自上而下**的过程，而组件的**挂载**是一个**自下而上**的过程；
2. 之所以会出现这样，原因是Vue在**创建的过程中**是一个**递归**的过程，先创建父组件，发现有子组件后就会创建子组件，因此创建过程自上而下；**子组件首次创建时会添加mounted钩子到队列中，等到patch结束再执行，因此子组件的mounted钩子会先进入到队列中**，因此挂载过程自下而上。

## 18. 怎么缓存当前的组件？缓存后如何更新？

### 回答

1. 在开发中缓存组件使用 **keep-alive** 组件，keep-alive 是Vue中的内置组件，其可以**缓存不活动的组件实例**，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。
2. keep-alive 组件可以**结合 include 和 exclude 属性来指定缓存哪些组件**。Vue3中不同的是，在Vue3中使用`router-view`包裹`keep-alive`。
3. 在缓存后如果想要获取数据，可以使用两种方式
   1. **beforeRouteEnter**：在有vue-router的项目中，每次进入路由都会执行`beforeRouteEnter`；
   2. **actived**：在 `keep-alive` 组件激活的时候执行`actived`钩子
4. keep-alive 是一个通用组件，它的内部定义了一个**map，用于缓存创建过的组件实例**，它返回的渲染函数内部会查找内嵌的 component 组件对应的组件VNode，如果该组件在 map 中存在就直接返回。由于 component 的 is 属性是个响应式数据，因此只要它变化，keep-alive 的 render函数就会重新执行。

## 19. 如何从0到1架构一个Vue项目

### 回答

1. 从0创建一个项目的话，我一般会做以下事情：**项目构建**、**插件引入**、**引入代码规范和提交规范**、**引入常用库和组件**。
2. 对于Vue3项目构建，一般来说使用 vite 或者 create-vue。
3. 引入常见的插件，比如说路有插件vue-router、状态管理vuex或者pinia、UI库的话一般是element-plus、HTTP工具axios。
4. 其他比较常用的库比如说vueuse、nprogress等。
5. 代码规范的话利用 prettier 和 eslint。
6. 项目结构方面，一般就是用 `src`放置项目代码文件、`router`放置项目路由配置、`components`放置项目通用组件、`store`放置状态管理工具配置。

## 20. 实际工作中总结的Vue最佳实践

### 回答

1. 在**编码风格**方面：
   * **命名组件的时候使用多词风格**，从而避免和HTML元素冲突；
   * 使用**细节化命名属性**而不是只有一个属性名；
   * **属性名命名使用驼峰命名，模板命名使用大驼峰命名**；
   * **使用 v-for 务必带上key，且不和 v-if 一起使用**。
2. **性能方面**：
   1. **使用路由懒加载**；
   2. **利用SSR减少首屏渲染时间**；
   3. **渲染不需要更新的内容的时候使用v-once**；
3. **安全方面**：
   1. **不信任用户输入的内容，不将用户的输入直接转换为DOM元素**；
   2. **小心使用v-html，防止注入攻击**。

## 21. 说一下对vuex的理解

### 回答

1. vuex 是一个专门为 Vue 开发的**状态管理工具**。采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化；
2. 一般来说开发者希望以一种简单的单向数据流方式管理应用，即**状态-->视图-->操作单向循环**的方式，但当遇到多个组件共享状态的时候，单向数据流的简洁性就很容易破坏，因此需要将组件共享状态提取出来以一个全局单例模式进行管理。这使得我们的代码更加容易维护。
3. vuex**是否使用需要结合需求来判断**，在开发小型应用的时候使用vuex反而带来开发的不便。
4. 使用的时候需要先创建一个 store 实例，里面存放 state、getter、mutation、action

### 补充：vuex 的缺点

**对于方法的使用**很不方便，因为分为两种方法：同步方法 mutations、异步方法 actions；

### 补充：action 和 mutation 的区别，以及为什么区分

1. action 是**异步方法**，调用的是 mutation，而 mutation 是**同步方法**；
2. 之所以区别是因为 mutation 混合调用异步方法会使程序很难调试，无法知道哪个函数先回调或是什么时候回调。

## 22. template 到 render 处理过程

### 回答

1. Vue 中存在着一个**编译器模块** compiler，这个模块的主要作用是将用户编写的 template 编译为 js 中可以执行的 render 函数；
2. 之所以要有这个编译过程是为了**更加高效的编写视图模板**，因为相对于写 render 函数来说，直接写 HTML 更加直观且高效；
3. 编译器会**将 template 进行解析**，解析完毕后得到一个**抽象语法树 AST**，这个 AST 是一个 JS 对象，之后对 AST 进行**深加工**，最后将生成的 AST **转化为 render 函数**。

### 补充：Vue中编译器是何时执行的

1. 编译器的执行时刻会**随着引入运行时变化**。
2. 如果是**webpack环境，我们使用的可能是预打包环境**，因为webpack中的loader会将编写的模板提前编译，此时执行的时刻就是打包时刻。
3. 如果是**非运行版本的话，编译工作就在运行时进行，因此在组件创建的时候进行编译**。

### 补充：react 有没有编译器

react 没有编译器，react 中使用的 jsx，这是一种语法糖，其语言并没有发生变化。

## 23. Vue 实例挂载过程发生了什么

### 回答

1. 挂载过程指的就是 `app.mount()` 过程，这个过程中主要做两件事：**初始化和创建更新机制**；
2. 初始化会**创建组件实例、初始化组件状态、创建各种响应式数据**；
3. 建立更新机制会**立即执行一次组件更新函数**，这会首次执行组件渲染函数并执行patch将前面获得的VNode转换为DOM；同时首次执行渲染函数会**创建响应式数据与组件更新函数之间的依赖关系**，从而使得数据变化执行对应的更新函数。

## 24. Vue3的设计目的以及优化

### 回答

1. Vue3 的设计目的主要是为了改进Vue2，相对 Vue2，Vue3 的**使用更加简便，性能更高，扩展性和可维护性更好，开发体验也更好了**；
2. Vue3 **对 API 的使用进行了简化**，比如 `v-model` 在 Vue3 中变成了 Vue2 中 `v-model` 和 `sync` 的结合体；
3. 性能方面，Vue3 中的**编译期优化以及基于 Proxy 的响应式系统**大大提升了性能；
4. 开发体验方面，使用**新增的 script setup 语法糖**能够很好的提升开发体验；
5. 扩展性方面，采用了**独立的 reactivity 模块**；
6. 由于**更好的支持了 typescript，以及增加了组合式api**，可维护性更好了；

### 补充：Vue3 的编译优化

对于传统的 diff 算法需要对比整个虚拟DOM，而在Vue3中为了区别动态节点和静态节点，**使用了 PatchFlags 来作为动态节点的标记**，通过 PatchFlags 将动态节点收集到Block 中。这样渲染器的更新就只会以 Block 为维度。

### 补充：Proxy 和 defineProperty 有什么不同

1. defineProperty **只能监听属性不能监听整个对象**，Proxy可以**直接监听整个对象**；
2. defineProperty 是**通过在原对象身上增改属性的方式实现监听**，会对原对象造成修改，Proxy 是对原对象的代理，**不会对原对象产生污染**；
3. defineProperty 对数组监听会**重写数组的方法**，Proxy **不会对数组方法重写**；
4. defineProperty 只能**监听到 value 的get、set变化**，Proxy可以监听范围更大，可以**监听除了`[[getOwnPropertyNames]]`以外所有 JS 的对象操作**。

## 25. 了解哪些Vue性能优化方法

### 回答

1. **路由懒加载**；
2. **keep-alive 组件缓存页面**；
3. **使用 v-show 来控制需要频繁切换的组件**；
4. **在使用 v-for 对列表进行渲染的时候不与 v-if 连用**；
5. **对于第三方库采用按需引入的方法**；
6. **使用 v-lazy 实现图片懒加载**；
7. 针对首屏渲染慢的问题，可以**使用服务端渲染方案**；

## 26. Vue组件为什么只能有一个根节点

### 回答

1. 在 **Vue2 中组件确实只能有一个根节点，但是在 Vue3 中组件已经可以多根节点了**。
1. 之所以需要这样是因为 **vdom 是一个单根树形结构**，patch 方法在遍历的时候从根节点开始遍历，要求只有一个根节点。组件也会装换为一个 vdom。
1. 在 Vue3 中可以使用多个根节点，这是因为引入了`Fragment`的概念，这是一个抽象节点，如果**发现组件是多根的，就会创建一个Fragment节点**，这多个根节点就作为它的children。在 **patch 的时候**，如果发现是一个Fragment 节点就**直接遍历它的 children 创建或更新**。

## 27. vuex 的 module 的使用

### 回答

1. 当项目的规模变大之后，单独一个的store对象会变得十分庞大且臃肿，此时就可以利用 modules 进行拆分，从而方便维护。
2. 可以按照之前的规则单独编写子模块代码，然后在主文件中通过`modules`选项进行组织。
3. 在使用时，**访问子模块状态需要加上注册模块时的模块名**，而`getters`、`mutations`和`actions`则在**全局空间**中，使用的方式和之前一样。如果要完全拆分，需要在子模块中加上`namespace`选项，之后再访问就需要加上命名空间前缀。
4. 虽然 modules 可以对代码进行拆分，但是**使用起来十分繁琐，容易出错**。因此在做状态管理使用 pinia 更好。

### 补充：pinia 有哪些改善

1. **取消了 mutations**，actions的使用和 methods 类似；
2. **对TS的支持更加友好**，所有的内容都是类型化的；
3. 不再需要注入、导入函数、调用函数、享受自动完成功能；
4. 无需动态添加 Store；
5. 取消了 modules 的嵌套结构；
6. 没有命名空间模块。

## 28. 如何实现路由懒加载

### 回答

1. 当打包应用的时候，JavaScript包会变得非常大，此时会影响页面的加载。利用路由懒加载就可以把不同的路由对应的组件分割，当路由被访问的时候才加载对应的组件。
2. 一般来说**应该对所有的路由都使用动态导入**。
3. 路由懒加载的**使用方式**是使用 components 选项配置一个返回 Promise 组件的函数从而实现路由懒加载。
4. 结合注释`webpackChunkName`可以实现 webpack 代码分块，在 vite 中则可以使用`rollupOptions`来定义分块。
5. 路由中不能使用异步组件。

## 29. ref 和 reactive 异同

### 回答

两者都可以用于构造响应式数据，区别是：

1. `ref`接收内部值返回响应式`Ref`对象，一般来说**用于单值的响应式处理**。而`reactive`则返回响应式代理对象，一般**用于处理对象类型的数据响应式**。
2. 在 JS 中对 ref 构造的响应式数据访问，**需要加上`.value`才可以**，在视图中的话则不需要加，会自动解包；ref 也**可以接收对象或数组等非原始值，但其内部实现仍然是采用`reactive`方式**；在 **reactive 内部如果接收 ref 对象会自动脱 ref**；如果**使用扩展运算符对 reactive 返回的响应式对象进行展开会导致响应式对象失去响应性**，需要结合 `toRefs()`将值转化为 Ref 对象后再展开。
3. 从实现原理来看，ref 内部封装了一个 RefImpl 类，并**设置 get value/set value**，拦截用户对值的访问，从而实现响应式。**reactive 内部则是使用 Proxy 代理的方式**传入对象并对对象的各种操作进行拦截，从而实现响应式。

## 30. watch 和 watchEffect 的异同

### 回答

1. `watchEffect`会**立即运行一个函数**，然后**被动地收集依赖**，当依赖改变的时候再重新执行函数。`watch`会**侦测一个或多个响应式数据源**，并在数据源发生变化的时候调用回调函数。
2. `watchEffect`是**一种特殊的`watch`**，**传入的函数既是依赖收集的数据源也是回调函数**。如果不需要关心依赖数据前后变化的值，那么就可以使用`watchEffect`。`watch`则更加底层，**可以获取依赖数据前后变化的值**。
3. `watchEffect`在使用的时候，传入函数**会立即执行一次**。而`watch`**默认情况下不会执行回调函数**，除非手动设置`immediate`选项。
4. 从实现上来说，`watchEffect`相当于`watch(fn, fn, {immediate: true})`。

## 31. SPA、SSR的区别是什么

### 回答

1. **SPA 指单页面应用**，也被称为客户端渲染。**SSR 指服务端渲染**，也被称为多页面应用。
2. SPA 应用只会**首次请求HTML文件，后续只需要请求 JSON 数据即可**，因此**用户体验更好，也更加节约流量，同时服务端的压力更小**。缺点是**首屏加载会变慢，且 SEO 不友好**。为了解决上述缺点就有了 SSR 方案，**HTML 内容在服务端一次性生成出来**，这样的**好处是首屏加载速度快，且搜索引擎也可以方便的抓取页面信息**。但同时 **SSR 方案也会有性能、开发受限等问题**。
3. 在选择上，如果**存在首屏渲染优化的需求就可以考虑 SSR 方案**。
4. 对于静态网站，SSR 反而会浪费资源，此时可以考虑使用预渲染方案。此外也可以使用next.js 中提供的 SSG 静态网站生成方案。

SSR

![ss](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f486234794794c8baf4f44496d8e824f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

SPA

![sp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5171c9f5a94447fc8f12d644ab31e078~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

## 32. vue-loader 是什么，有什么作用

### 回答

1. `vue-loader`是一个用于处理单文件组件的webpack loader，主**要作用是将Vue组件编译为 js 代码**。
2. 因为有`vue-loader`，因此才可以在项目中使用 SFC 格式来编写 Vue 组件，可以把代码分割为`<template>`、`<script>`、`<style>`，使得我们的组件结构更加清晰。配合其他的 loader，可以在组件中使用 TS 和 SASS。也可以使用 scope 使`<style>`单独作用于当前组件。
3. 在 webpack 打包的时候，以 loader 的方式调用 `vue-loader`。
4. `vue-loader`被执行的时候，对SFC中的每个语言块采用单独的 loader 链来处理，最后将这些单独的块装配成最终的组件模块。

## 33. 自定义指令及其使用场景

### 回答

1. Vue 中存在着一些默认指令，如 `v-model`或`v-for`等，同时Vue也允许用户注册自定义指令来扩展 Vue 的能力。
2. 使用自定义指令**分为定义、注册和使用三步**；
   * 自定义指令有两种方式：**对象和函数形式**，前者类似组件定义，有各种声明周期，后者则只在 mounted 和 updated 时执行；
   * 注册自定义指令类似组件，可以使用`app.directive()`全局注册，使用`{directives: {xxx}}`局部注册，在 `<script setup>`中只需要使用`vXxx`的方式即可注册。
   * 使用时在注册名称前面加上`v-`即可。
3. 在项目中常用的自定义指令有：防抖`v-debounce`、按钮权限`v-premission`等。
4. Vue3 中指令定义的主要变化就是钩子函数的名称与组件一致，此外**可以在 setup 中使用比较方便的方式来定义自定义指令**。

## 34. 说下 \$attrs 和 \$listeners 的使用场景

### 回答

1. 可能有一些属性和事件并**没有在props中定义**，这类被称为**非属性特性**，结合 v-bind 指令可以直接透传给子组件；
2. 这类属性透传**常常作用于包装高阶组件时往内部传递属性**，常常用于爷孙组件之间传参。
3. 最常见的用法是结合 v-bind 做展开；**\$attrs本身不是响应式的**，除非访问的属性本身是响应式对象。
4. Vue2 中使用 listeners 获取事件，在Vue3中**已经移除，合并到 attrs 中**。

## 35. v-once 的使用场景有哪些

### 回答

1. v-once 是Vue的**内置指令**，**作用是仅渲染指定组件或元素一次，并跳过未来对其更新**。
2. v-once 一般**适用于元素或组件在初始化渲染后不再需要变化的情况**，使用的时候只需要在组件或元素上加上 v-once 即可。
3. Vue 中也增加了一个 **v-memo 指令**，该指令**可以有条件的缓存部分模板并控制更新**。
4. 当编译器发现有 v-once 的时候，**会将首次计算结果存入缓存**，当组件再次渲染的时候从缓存中获取，从而避免再次计算。

## 36. 什么是递归组件

### 回答

1. 如果某个组件**通过组件名称引用自身**，这种情况就是递归组件。
2. 在实际开发中**开发类似 Tree、Menu 这类组件**，它的节点中子节点结构和父节点往往是相同的。这时就可以使用递归组件。
3. 使用递归组件的时候，需要避免在组件内部导入自己，因此**需要设置组件`name`属性**，用来查找组件定义。如果使用 SFC，则可以通过 SFC 文件名推断。**组件内部通常也要有递归结束条件，比如 model.children 这样的判断**。

## 37. 异步组件是什么？使用场景有哪些？

### 回答

1. 在大型应用中，需要**将应用分割为更小的块并且在需要的时候再加载它们**。
2. 我们不仅可以在路由切换的时候使用懒加载，也可以在页面组件中使用异步组件，从而实现更细的分割。
3. 可以使用`defineAsyncComponent`来接收一个返回 Promise 的加载函数，也**可以结合ES的模块动态导入使用**。可以在高级选项中使用`loadingComponent`和`errorComponent`来处理加载和错误状态。也可以使用一个实验性的`<Suspense>`组件来使用异步组件。
4. 异步组件和路由懒加载并不是一个东西。**异步组件不能用于定义路由懒加载，处理异步组件使用的是 Vue 框架，处理路由组件懒加载使用的是 vue-router**。可以在懒加载的路由组件中使用异步组件。

## 38. 如何处理Vue项目中的错误

### 回答

1. 一般来说错误类型分为两种：**接口异常和代码逻辑异常**。
2. 对于不同的错误类型需要做相应的处理：接口类型是在请求后端接口的时候发生的异常，可能是请求失败，也可能是请求获得了服务器响应，但是返回的是错误的状态。以 Axios 为例，**可以通过封装 Axios，在拦截器中统一处理整个应用中的请求错误**。代码逻辑异常是指编写的前端代码中存在逻辑上的错误导致的异常，在 Vue 中采用**全局错误处理函数`app.config.errorHandler`收集错误**。
3. 收集到错误后，需要对异常进行统一处理，如分析错误，获取需要错误信息和数据。需要对错误类型进行区分，如果是请求错误就需要**上报接口信息、参数、状态码等**。如果是逻辑错误，需要**获取错误名称和详情**。这些信息可以通过vuex存储的全局状态和路由信息获得。

## 39. 如何从0写一个vuex

### 回答

1. vuex 是一个状态管理库，如果要实现一个 vuex，需要实现以下几点：
   * **实现一个用于存储全局状态的`Store`**
   * **提供修改状态所需的API**：`commit(type, payload)`，`dispatch(type, payload)`
2. 对于`Store`的实现可以**定义Store类，构造函数接收选项 options，设置属性 state 对外暴露状态，提供 commit 和 dispatch 方法用于修改 state。state 需要设置为响应式对象，同时需要将 Store 定义为一个 Vue 插件。**
3. commit 方法中**可以获取用户传入的 mutations 并执行**，这样就可以使用用户提供的方法修改状态。**dispatch** 与 commit 类似，但需要注意的是因为**可能是异步的**，所以**需要返回一个 Promise** 给用户来处理异步结果。

## 40. vuex 中 actions 和 mutations 有什么区别

### 回答

1. 在 vuex 中**更改 store 中状态的唯一办法是提交 mutation**，mutation 类似于事件，每个 mutation 都有一个字符串的类型（type）和一个回调函数（handler）。action 的功能类似 mutation，不同的是：action 可以包含任意异步操作，但**不能修改状态，需要通过提交 mutation 的方法才能修改状态**。
2. 在开发的时候，**包含异步操作或复杂业务组合的时候使用 action**，**需要直接修改状态的时候使用 mutation**。由于 dispatch 和 commit 是两个API，容易引起混淆，事件中一般统一采取 dispatch action 的方式。
3. 调用 dispatch 和 commit 两个API时几乎完全一样，但是定义两者时却不相同，mutation 的回调函数接收参数是 state 对象。action 则是接收与 Store 实例具有相同的方法和属性的上下文对象 context，因此一般会解构它为`{commit, dispatch, state}`从而方便编码。此外，dispatch 会返回 Promise 实例便于处理内部异步结果。
4. 实现上 commit 相当于调用`options.mutations[type](state)`，dispatch 相当于调用`options.actions[type](store)`。

## 41. Vue 长列表优化思路

### 回答

1. 在大型项目中常常遇到需要渲染大量数据的情况，此时很容易出现卡顿。
2. 为了处理这种情况可以采用如下方法：
   1. 采取**分页的方式来获取数据**，避免渲染大量数据。
   2. 采用 vue-virtual-scroller 等**虚拟滚动方案**，**只渲染视口范围内的数据**。
   3. 对于**不需要更新的数据采用`v-once`进行渲染**；
   4. 也**可以采用 v-memo 结合 v-for 使用**，从而避免数据变化时不必要的Vnode创建。
   5. 可以**采用懒加载的方式，在用户需要的时候再加载数据**。
3. 总之，首先应当在设计上避免大量数据的获取和渲染，如果实在需要，就可以采用虚表的方式优化渲染，最后考虑对更新进行优化，对于不需要更新的情况可以使用 v-once，对于需要更新的可以使用 v-memo 对数据更新进行优化。其他可以采用的就是交互方式优化、无限滚动、懒加载等方案。

## 42. 如何监听 vuex 数据的变化

### 回答

1. 有两种方法可以实现：第一种方法是**使用 watch 进行监听**，第二种方法是**使用 vuex 提供的API：`store.subscribe()`**。
2. watch 选项方式可以以字符串的形式监听`$store.state.xx`；subscribe 方式则是调用`store.subscribe(cb)`，在回调函数中接收 mutation 对象和 state 对象，从而进一步判断`mutation.type`是否为期待的那个，从而进一步做后续处理。
3. 总体来说，**首选watch方式**，因为简单好用，且能获取前后数据的变化值；subscribe方式会被所有 commit 行为触发，因此需要判断 `mutation.type`，因此用起来比较繁琐，一般用于vuex插件中。

## 43. router-link 和 router-view 是如何起作用的

### 回答

1. router-link 和 router-view 是 vue-router 中的重要组件，分别起到**路由导航和组件内容渲染**的作用；
2. 使用 router-link 会默认生成一个a标签，设置 to 属性定义跳转 path，也可以通过 custom 和插槽自定义最终的展现形式。router-view 是要展示组件的占位组件，可以嵌套，对应路由配置的嵌套关系，配合 name 可以显示具名组件，起到更强的布局作用。
3. router-link 组件内部根据 custom 属性判断如何渲染最终生成节点，**内部提供导航方法navigate**，用户点击实际上调用的是该方法，此方法最终会**修改响应式的路由变量，然后重新去 routes 中匹配出数组结果**，router-view 则**根据其所处深度 deep 在匹配数组结果中找到对应的路由并获取组件，最终将其渲染出来**。

## 44. vue-router 除了 router-link 怎么实现跳转

### 回答

1. vue-router 中有两种导航方式，分别为：**声明式导航和编程式导航**。
2. 声明式导航**使用 router-link 组件**，通过设置 to 属性来进行导航。编程式导航则是利用**`router.push()`并传递 path 字符串或设置 RouteLocationRaw 对象**，可以指定 path、name、params 等信息。
3. 如果只是简单的跳转，使用声明式导航更好，如果页面内容比较复杂，使用编程式导航。
4. 这两种方式内部调用的导航函数是一样的。

## 45. Vue3 的性能提升体现在哪里

### 回答

1. 主要体现在**代码、编译、打包**这三个方面上。
2. 在代码方面的优化主要在**全新的响应式API**上，新的reactive基于Proxy实现，其初始化的时间和内存占用大幅减少；
3. 编译层面的优化主要体现在采用了**静态提升、动态标记、事件缓存以及区块**等，有效减少了diff过程；
4. 打包的优化体现在**更好的 tree-shaking** 上，因此整体体积更小，加载更快。

## 46. Vue3 中为什么要使用 Proxy 替代 defineProperty

### 回答

1. JS 中用来做属性拦截的常见方式有三种：defineProperty、getter/setter、Proxy。
2. Vue2中之所以使用 defineProperty 是因为当时只支持这种方式。这个 API 存在一些局限性，比如对于数组的拦截有问题，因此需要对数组响应式做一套实现。此外不能拦截新增、删除属性。defineProperty 在初始化的时候需要做一次深度递归遍历才能实现对对象的拦截，因此初始化时间较长。
3. Proxy 既**可以实现对于数组的拦截，也可以对新增的 Map、Set 实现拦截**。此外，Proxy 的拦截是**一个懒处理的行为，因此可以大大优化初始化的速度和内存占用**。
4. Proxy 的缺点是对 IE 不支持，因此如果在方案需要考虑到兼容性问题的时候就不能使用 Vue3 了。

## 47. History 模式和 Hash 模式的区别

### 回答

1. vue-router 中有三种路由方式，其中比较常用的是 history 和 hash，两者的主要区别在URL 的显示形式上以及 SEO 与部署方面。
2. hash 模式在地址栏的表现形式表现为`#/xxx`，这种方式使用和部署较为简单，但缺点是搜索引擎无法处理，存在 SEO 问题。history 模式表现的更为优雅，但需要**在部署的时候做特殊配置**，服务器需要做回退处理，否则会出现刷新页面404的问题。
3. 在底层实现原理方面，hash 模式是 history 的一种特殊实现。

## 48. 嵌套路由的使用

### 回答

1. 在开发过程中，应用的有些界面是由多层级组件组合而来的，此时，URL 的各部分通常对应着某个嵌套组件，因此，vue-router 可以使用嵌套路由表示这种关系。
2. 在表现形式上，在两个路由之间切换时，它们存在公用的视图内容。此时可以**提取为一个父组件**，从而形成物理上的嵌套，与逻辑上的嵌套对应起来。
3. **定义嵌套路由的时候使用 children 属性来组织嵌套关系**。
4. 在实现原理上，router-view 组件内部判断当前 router-view 在嵌套层级中的深度，将这个深度作为匹配组件数组 matched 的索引，获取对应渲染组件，完成渲染。

## 49. 页面刷新后 vuex 的 state 数据丢失怎么解决

### 回答

1. vuex **只是在内存中保存状态，因此刷新之后就会丢失**，如果想要持久化，就必须存起来。
2. **可以使用 localStorage**，每次提交mutation的时候存入 localStorage，store 把值取出作为state的初始值即可。
3. 这样做的问题是并不是所有状态都需要持久化，如果需要保存的状态很多，就会导致编写的代码不够优雅，每个提交的地方都需要做保存处理。因此**可以使用 vuex 提供的 subscribe 方法来做统一处理**。
4. 也**可以使用插件 vue-persist来进行实现**，内部的原理就是通过订阅mutation变化来做统一处理，通过插件的选项控制哪些需要持久化。

## 50. vuex 有哪些缺点

### 回答

1. vuex 为 Vue 提供了一个很好的全局状态管理，使用起来较为方便快捷，但**在模块化方面的处理仍然过于复杂**。
2. 在访问 state 的时候需要加上模块 key，如果内嵌模块的话就会很长，需要配合 mapState 进行使用。此外加不加 namespace 的区别也很大，getters、mutations、actions这些默认是在全局中的，如果加上了就必须使用字符串类型的 path 来进行匹配，由于使用模式不统一，容易出错。此外**对于TS的支持也不友好**，使用模块时没有代码提示。
3. pinia 的使用体验更加友好，目前官方建议使用 pinia 来作为全局状态管理工具。

## 51. 组合式 API 与选项式 API 的不同

### 回答

1. **组合式 API 是一组 API**，包括：Reactivity API、生命周期钩子、依赖注入，**使用户可以通过函数方式编写Vue组件**。**选项式 API 则通过声明组件选项的对象形式编写组件**。
2. 组合式 API 的优点是能够简洁、高效复用逻辑。同时解决了过去选项式API中`mixins`的各种缺点。在组件增长过大的时候，选项式 API 就会比较臃肿，逻辑关注点分散在各处，维护的时候需要反复横跳。组合式API 可以将这些逻辑组织在一起。组合式API具有更好的类型推断，对于TS的支持更加友好。
3. 对于低复杂度的项目，使用选项式API更好，对于高复杂度的项目，更推荐使用组合式API。

### 补充：组合式API和选项式API能否一起使用

**可以**。**可以在一个选项式API中使用`setup()`选项**。但是只推荐在一个基于选项式API开发了很久，但需要与基于组合式API的代码或第三方库整合的时候使用。

## 52. vue-router 如何保护路由

### 回答

1. vue-router 中**保护路由的方法是路由守卫**，**主要通过跳转或取消的方式守卫路由**。
2. 路由守卫有三个级别：**全局、路由独享、组件级**。影响范围从大到小。例如在全局中使用`router.beforeEach()`可以注册一个全局前置守卫，每次路由导航经过这个守卫，因此再其内部可以加入控制逻辑决定用户是否可以导航到目标路由。路由注册的时候可以加入单路由独享的守卫，例如 beforeEnter，守卫只在进入路由的时候触发，因此只会影响这个路由，控制更加精确。还可以为路由组件添加守卫配置，如 beforeRouteEnter，会在渲染该组件的对应路由被验证前调用，控制范围更加精确。
3. 用户的任何导航行为都会走 navigate 方法，其内部有一个 guards 队列按顺序执行用户注册的守卫钩子函数。如果没有通过验证逻辑就会取消原有的导航。

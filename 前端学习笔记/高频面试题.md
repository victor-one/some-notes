# 高频面试题

## 1. JS有哪些数据类型以及它们的区别

**基本数据类型**：number, string, boolean, null, undefine, bigInt, symbol；

**引用数据类型**：Object；

**区别**：

1. 基本数据类型存放在**栈**中，引用数据类型存放在**堆**中；
2. 访问基本数据类型时，可以直接操作存放在存放在栈中的值，引用数据类型不可以直接访问堆类型空间，**只能操作存放在栈中的引用地址**；
3. 基本数据类型复制，直接复制值，引用数据类型复制，**复制的是引用地址**。

## 2. JS基本数据类型中null和undefined的区别

这两个类型都表示没有值，区别在于：

1. null表示没有对象，该处**不应该有值**；undefined表示缺少值，该处**应该有**一个值，但是还没有定义。
2. null转为数值为**0**，undefined转为数值的时候为**NaN**。

什么时候有null：

1. 作为函数的参数，表示该函数的参数不是对象；
2. 作为**原型链的终点**。

什么时候有undefined：

1. **变量**被声明了，但是没有赋值，该变量就为undefined；
2. 调用函数时，应该提供的**参数没有提供**，该参数就等于undefined；
3. 对象**没有赋值的属性**，属性的值就为undefined；
4. 函数**没有返回值**得时候，默认返回值就是undefined。

## 3. JS数据类型检测方式有哪些

1. **typeof**（检测数据类型的运算符）--> 无法检测对象，会将null判断为object（浏览器的一个BUG，这是因为所有的值在计算机中都是用二进制编码存储，浏览器将前三位都为0的当做对象处理，null的所有都为0，因此也被当做对象）。
2. **instanceof** （检测某个实例是否属于这个类）--> 可以正确地判断对象的类型，因为内部运行机制就是判断在它的原型链上能不能找到这个类型的原型。**不能判断基本数据类型。不可以检测undefined和null。**
3. **constructor** （检测实例和类的关系，从而检测数据类型）--> 引用原来构造该对象的函数。不可以检测undefined和null。
4. **Object.prototype.toString.call()** （检测数据类型）

## 4. 手写instanceof

```javascript
function myInstanceof (left, right) {
  // 获取目标实例的原型对象
  let proto = Object.getPrototypeOf(left);
  // 获取检测构造函数的原型对象
  const prototype = right.prototype;
  while(true) {
    // 原型对象不存在的时候，就是一直追溯直到Object.prototype._proto_
    if (!proto) {
      return false;
    }
    // 如果找到对应的原型对象
    if (proto == prototype) {
      return true
    }
    // 没找到，到下一级原型中寻找
    proto = Object.getPrototypeOf(proto);
  }
}

const a = myInstanceof([1, 2, 3], Object); // true
console.log(a);
const b = myInstanceof({}, Array); // false
console.log(b);
```

## 5. typeof NaN 的结果是什么

结果为 **number**。

NaN表示不是一个数字（Not A Number），表示是否属于 number 类型的一种状态：是或否，**不是一个确切的值**。

JS中number数据类型除了浮点型和整数型，还有一个特殊的NaN。

NaN，表达式中存在不可转化的变量，并且返回的是一个无效的结果，不是返回确切的值。

NaN **与本身并不相等**，因为它不是一个确切的值，代表的是一个范围。

## 6. JS 中判断数组的方法

1. `Object.prototype.toString.call()`
2. 通过**原型链**做判断，**对象的隐式原型等于构造函数的显式原型**
3. 通过 ES6 的 `Array.isArray()`做判断
4. 通过 `instanceof`做判断
5. 通过`Array.prototype.isPrototypeOf`做判断，判断 Array 是否在传入内容的原型链上。

## 7. JS 中 \+ 操作符什么时候用于字符串的拼接

如果 \+ 操作符**其中一个操作数是字符串**（或者如果是对象，通过`ToPrimitive`操作之后最终得到的字符串），则执行字符串的拼接，否则执行数字加法。

`ToPrimitive` 操作是先使用`valueOf` ，如果结果不是基本数据类型就调用对象的`toString`方法。

注意：函数、数组的`toString`方法结果与对象不同

## 8. JS 中 Object.is() 与比较操作符"\=\=\="和"\=\="的区别

**双等号**（**\=\=**）：如果两边的类型不一致，会**进行强制类型转换**，然后再比较

**三等号**（\=\=\=）：如果两边类型不一致，**不会进行强制类型转换**，直接返回false

注意：三等号判断`NaN`会返回false，判断`+0 === -0`会返回true（这是因为`+`会将不是number的类型转换为number）

`Object.is()`：判断**两个值是否为同一个值**，判断`+0 === -0`会返回false，判断`NaN`会返回true。

## 9. JS 如何进行隐式转换

隐式转换是调用`toPrimitive`方法，方法里面可以传入两个参数，分别为要转换的对象 obj 以及要转换的类型 type 。type可以为 number 或者 string ，默认情况下为 number 。

当为 number 时，先调用 obj 的`valueOf`，如果不是原始值，调用 obj 的`toString`，否则抛出类型错误。

当为 string 时，先调用`toString`，后调用`valueOf`，否则抛出类型错误。

## 10. 深拷贝和浅拷贝的区别

主要区别在于**对对象的复制**，浅拷贝复制的是对象在堆内存中的引用地址，而深拷贝则是将对象在堆中另存到一个新的引用地址上。浅拷贝对其中的对象进行操作会对原始数据产生影响，深拷贝则不会。

深拷贝的实现：

最简单的方法可以**通过JSON对象实现深拷贝**（但是此方法无法解决循环引用的问题）：

* `JSON.stringify`：将 js 的值转为一个 JSON 字符串（因为会重新分配内存）
* `JSON.parse`：用来解析 JSON 字符串，转化为 Object 类型

注意：使用扩展运算符实现的是浅拷贝。

手写深拷贝：

```javascript
function clone(target, map = new Map()) {
    // 判断是否为基本数据类型
    if (typeof target !== 'object' || target === null) {
        return target;
    }
    // 初始化
    const cloneTarget = target instanceOf Array ? [] : {};
    // 防止循环引用
    if (map.get(target)) {
        return map.get(target);
    }
    map.set(target, cloneTarget);
    
    for( key in target) {
        cloneTarget[key] = clone(target[key], map);
    }
    return cloneTarget;
}
```

实际使用的时候一般使用 loadsh 包，引用其中的cloneDeep函数。

## 11. JS 中与和或的返回值

# Sass 笔记

## 1. 特色功能

* 完全兼容 CSS3
* 在 CSS 基础上增加变量、嵌套（nesting）、混合（mixins）等功能
* 通过函数进行颜色值与属性值的运算
* 提供控制指令等高级功能
* 自定义输出格式

## 2. 语法格式

有两种语法格式：scss 和 sass。它们的区别如下：

1. scss 使用`/* */` 进行注释；sass 使用 `/*` 进行注释
2. scss 使用`//`注释，每行注释前面都必须写`//`；sass 使用`//`注释，只需要在第一行前面写`//`，其他行只需要缩进一下就可以了。
3. scss 使用`@import` ，需要在导入的东西上加上`""`；sass 则不需要加上引号。
4. scss 使用`@mixin`需要写出来，并且`mixin`的主体要写在一组花括号里面，并且在每一段代码的结束都得写上`;`；sass 中使用`=`来代替，且不需要花括号，每行的结束也不需要`;`。
5. 引入 mixin 的时候，scss 需要使用`@include`；sass 则使用`+`来进行引入。

## 3. 使用 Sass

需要先安装 Sass gem（Windows 需要先安装 Rubby）

```sh
gem install sass
```

编译 sass 文件：

```sh
sass input.scss output.css
```

监视sass文件，每次修改保存后自动编译：

```sh
sass --watch input.scss:output.css
```

监视整个文件夹：

```sh
sass --watch app/sass:public/stylesheets
```

### 修改编译输出的格式

一共有四种格式：

* nested，嵌套
* compact，紧凑
* expanded，扩展
* compressed，压缩

默认编译输出的使用的是嵌套的格式

## 4. CSS 功能扩展

### 4.1 嵌套规则

```scss
#main p {
  color: #00ff00;
  width: 97%;

  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}
```

### 4.2 父选择器`&`

可以用`&`代表嵌套规则外层的父选择器

```scss
a {
  font-weight: bold;
  text-decoration: none;
  &:hover { text-decoration: underline; }
  body.firefox & { font-weight: normal; }
}
```

如果含有多层嵌套，最外层的父选择器会一层一层向下传递

```scss
#main {
  color: black;
  a {
    font-weight: bold;
    // 此处的 & 指的是 #main a:hover
    &:hover { color: red; }
  }
}
```

`&`必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器

```scss
#main {
  color: black;
  // 编译为 #main-sidebar
  &-sidebar { border: 1px solid; }
}
```

### 4.3 属性嵌套

```scss
.funky {
  font: {
  	// font-family、font-size、font-weight
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```

命名空间也可以包含自己的属性值

```scss
.funky {
  font: 20px/24px {
    family: fantasy;
    weight: bold;
  }
}
```

### 4.4 占位符选择器`%foo`

Sass 额外提供了一种特殊类型的选择器：占位符选择器，与常用的 id 与 class 选择器写法相似，只不过是用`%`。必须通过`@extend`指令调用，如果单独使用（没有调用）的时候，不会编译到 CSS 文件中。

## 5. 注释

多行注释：`/* */`

单行注释：`//`

需要注意的是，多行注释会被完整输出到编译后的 CSS 文件中，而单行注释不会。

插值语句也可写进多行注释中输出变量值。

```scss
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
```

编译结果：

```css
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
```

## 6. SassScript

### 6.1 Interactive Shell

利用 Interactive Shell 可以在命令行中测试 SassScript 的功能。在命令行中输入 `sass -i`，然后输入想要测试的语句查看结果：

```sh
$ sass -i
>> "Hello, Sassy World!"
"Hello, Sassy World!"
>> 1px + 1px + 1px
3px
>> #777 + #777
#eeeeee
>> #777 + #888
white
```

### 6.2 变量 `$`

以`$`开头，赋值方法与 CSS 属性写法一致：

```scss
$width: 5em
```

可以直接调用变量：

```scss
#main {
  width: $width;
}
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用，不在嵌套规则内定义的变量则可以在任何地方使用（全局变量）。

可以使用`!global`将局部变量转换为全局变量。

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```

### 6.3 数据类型

支持6种主要的数据类型

* 数字，`1, 2, 13, 10px`
* 字符串，有引号字符串与无引号字符串，`"foo", 'bar', baz`
* 颜色，`blue, #4432ef, rgba(255,0,0,0.5)`
* 布尔型，`true, false`
* 空值，`null`
* 数组（list），用空格或逗号作为分隔符，`1.5em 1em 0 2em, Helvetica, Arial, sans-serif`
* maps，相当于 JS 中的 object，`(key1: value1, key2: value2)`

#### 6.3.1 字符串

支持两种字符串类型：有引号字符串和无引号字符串。使用`#{}`，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名。

#### 6.3.2 数组

可以使用`nth`函数直接访问数组中的某一项；`join`函数可以将多个数组连接在一起；`append`函数可以在数组中添加新值；而`@each`指令能够遍历数组中的每一项。

数组中可以包含子数组，有两种分隔方式：`1px 2px, 5px 6px` 和 `(1px 2px) (5px 6px)`。

但是这两种方法在 sass 中含义不同，第一种表示包含四个值的数组，第二种表示包含两个数组的数组。

可以用`()`表示不包含任何值的空数组。空数组不可以直接编译成 CSS，会报错。如果数组中包含空数组或空值，编译时将被清除。

用逗号分隔的数组允许保留结尾的逗号。

#### 6.3.3 Maps

与数组不同，Maps 必须用圆括号包围。

#### 6.3.4 颜色

没啥好说的，和 CSS 中一样。

### 6.4 运算

所有的数据类型均支持相等运算 `==` 或 `!=`，此外每种数据类型也有各自支持的运算方式。

#### 6.4.1 数字运算

`+, -, *, /, %`

如果必要会在不同单位间转换值。

关系运算 `<, >, <=, >=` 也可用于数字运算，相等运算 `==, !=` 可用于所有数据类型。

**除法运算**：以下三种情况被视为除法运算符号

* 如果值，或值的一部分，是变量或者函数的返回值；
* 如果值被圆括号包裹
* 如果值是算数表达式的一部分

```scss
p {
  font: 10px/8px;             // Plain CSS, no division
  $width: 1000px;
  width: $width/2;            // Uses a variable, does division
  width: round(1.5)/2;        // Uses a function, does division
  height: (500px/2);          // Uses parentheses, does division
  margin-left: 5px + 8px/2px; // Uses +, does division
}
```

编译为：

```css
p {
  font: 10px/8px;
  width: 500px;
  height: 250px;
  margin-left: 9px; }
```

如果需要使用变量，同时又确保`/`不做除法，需要使用`#{}`插值语句将变量包裹。

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
}
```

#### 6.4.2 颜色值运算

颜色值的运算是分段计算进行的。

需要注意的是，如果使用 rgba 或 hsla，必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。

颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。

```scss
$translucent-red: rgba(255, 0, 0, 0.5);
p {
  color: opacify($translucent-red, 0.3);
  background-color: transparentize($translucent-red, 0.25);
}
```

编译为：

```css
p {
  color: rgba(255, 0, 0, 0.8);
  background-color: rgba(255, 0, 0, 0.25); }
```

IE 滤镜要求所有颜色值必须包含 alpha 层，因此可以使用 `ie_hex_str` 函数将颜色转化为 IE 滤镜要求的格式。

```scss
$translucent-red: rgba(255, 0, 0, 0.5);
$green: #00ff00;
div {
  filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#{ie-hex-str($green)}', endColorstr='#{ie-hex-str($translucent-red)}');
}
```

#### 6.4.3 字符串运算

`+` 可用于连接字符串，如果 `+` 左侧为引号字符串，则运算结果有引号，若左侧无引号字符串，结果没有引号。

运算表达式与其他值连用的时候，用空格做连接符。

在有引号的文本字符串中可以使用`#{}`插值语句可以添加动态的值。

空的值被视作插入了空字符串。

#### 6.4.4 布尔运算

`and`、`or`、`not` 运算

#### 6.4.5 数组运算

数组不支持任何运算方式，只能用 list functions 控制。

### 6.5 圆括号

圆括号可以用来影响运算顺序。

### 6.6 函数

SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：

```scss
p {
  color: hsl(0, 100%, 50%);
}
```

编译为

```css
p {
  color: #ff0000; }
```

允许使用关键词参数，上述例子可以写成：

```scss
p {
  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}
```

这样写阅读起来更加方便，且关键词参数可以打乱顺序使用，如果使用默认值也可以缺省。

### 6.7 插值语句 `#{}`

通过`#{}`插值语句可以在选择器或属性名中使用变量。

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

使用`#{}`可以避免 Sass 运行运算表达式，直接编译 CSS

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
}
```

编译为

```css
p {
  font: 12px/30px; }
```

### 6.8 `&`

`&` 在 SassScript 中指现在的父选择器，它是一个用逗号分隔的列表。如果父选择器不存在的话，`&` 的值就会是 null，这意味着，我们可以在一个 mixin 中使用它来判断是否父选择器存在。

### 6.9 变量定义 `!default`

可以在变量的结尾添加`!default`给一个未通过`!default`声明赋值的变量赋值。此时，如果变量已经被赋值，不会再被重新赋值，如果还没赋值，就会被赋予新的值。

当变量是 null 空值时将视为未被`!default`赋值。

## 7. @-Rules 与指令

### 7.1 @import

Sass 扩展了 `@import` 的功能，允许其导入 scss 或 sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令（mixin）都可以在导入的文件中使用。

通常，`@import` 寻找 Sass 文件并将其导入，但在以下情况，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件：

* 文件扩展名为`.css`；
* 文件名以`http://`开头；
* 文件名是`url()`；
* `@import`包含 media queries；

如果不在上述情况内，文件的扩展名为`.scss` 或 `.sass`，则导入成功。如果没有指定扩展名，Sass 会试着寻找文件名相同，扩展名为`.scss`或`.sass`的文件并导入。

```scss
@import "foo.scss";
```

或

```scss
@import "foo";
```

都会导入文件 foo.scss。

```scss
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

编译为

```css
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

允许同时导入多个文件。

```scss
@import "first", "second";
```

导入文件也可以使用`#{ }`插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 `url()` 导入方式。

```scss
$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}");
```

编译为

```css
@import url("http://fonts.googleapis.com/css?family=Droid+Sans");
```

#### 7.1.1 分音

如果需要导入 Scss 或 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前加下划线，这样就会不编译这些文件，但是在导入语句中不需要添加下划线。

不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。

#### 7.1.2 嵌套@import

一般在文件的最外层使用`@import`，也可以将`@import`嵌套进 CSS 样式或者 `@media` 中。

不可以在混合指令（mixin）或控制指令（control directives）中嵌套`@import`。

### 7.2 @media

Sass 中 `@media`指令与 CSS 中用法一样，但是允许其在 CSS 规则中嵌套。如果嵌套在 CSS 规则内，编译时，`@media` 将被编译到文件的最外层，包含嵌套的父选择器。

```scss
.sidebar {
  width: 300px;
  @media screen and (orientation: landscape) {
    width: 500px;
  }
}
```

编译为

```css
.sidebar {
  width: 300px; }
  @media screen and (orientation: landscape) {
    .sidebar {
      width: 500px; } }
```

`@media` 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 `and`

也可以使用 SassScript （比如变量、函数、以及运算符）代替条件的名称或者值：

```scss
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;

@media #{$media} and ($feature: $value) {
  .sidebar {
    width: 500px;
  }
}
```

编译为

```css
@media screen and (-webkit-min-device-pixel-ratio: 1.5) {
  .sidebar {
    width: 500px; } }
```

### 7.3 @extend

使用`@extend`可以告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

上述代码的意思是将 `.error` 下的所有样式继承给 `.seriousError`，`border-width: 3px;` 是单独给 `.seriousError` 设定特殊样式。

其他使用到 `.error` 的样式也会同样继承给 `.seriousError`。

#### 7.3.1 工作原理

`@extend` 的作用是将重复使用的样式延伸（extend）给需要包含这个样式的特殊样式。

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.error.intrusion {
  background-image: url("/image/hacked.png");
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

编译为

```css
.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd; }

.error.intrusion, .seriousError.intrusion {
  background-image: url("/image/hacked.png"); }

.seriousError {
  border-width: 3px; }
```

#### 7.3.2 延伸复杂的选择器

Sass 允许延伸任何定义给单个元素的选择器，比如 `.special.cool`，`a:hover`或者`a.user[href^="http://"]`等。

#### 7.3.3 多重延伸

同一个选择器可以延伸给多个选择器（就是可以`@extend`多个选择器），它所包含的属性将继承给所有被延伸的选择器。

此时，后定义的样式享有优先权。

多重延伸可以使用逗号分隔选择器名，如 `@extend .error, .attention;` 与 `@extend .error; @extend .attention`有相同的效果。

#### 7.3.4 继续延伸

当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个。

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
.criticalError {
  @extend .seriousError;
  position: fixed;
  top: 10%;
  bottom: 10%;
  left: 10%;
  right: 10%;
}
```

编译为

```css
.error, .seriousError, .criticalError {
  border: 1px #f00;
  background-color: #fdd; }

.seriousError, .criticalError {
  border-width: 3px; }

.criticalError {
  position: fixed;
  top: 10%;
  bottom: 10%;
  left: 10%;
  right: 10%; }
```

#### 7.3.5 选择器列

不可以将选择器列延伸给其他元素，但是可以将其他元素延伸给选择器列。

```scss
#fake-links .link {
  @extend a;
}

a {
  color: blue;
  &:hover {
    text-decoration: underline;
  }
}
```

编译为

```css
a, #fake-links .link {
  color: blue; }
  a:hover, #fake-links .link:hover {
    text-decoration: underline; }
```

有时需要将选择器列中的某个元素延伸给另一个选择器列，这种情况下，两个选择器列需要合并。

两个列合并的时候，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：

```scss
#admin .tabbar a {
  font-weight: bold;
}
#demo .overview .fakelink {
  @extend a;
}
```

编译为

```css
#admin .tabbar a,
#admin .tabbar #demo .overview .fakelink,
#demo .overview #admin .tabbar .fakelink {
  font-weight: bold; }
```

如果两个列包含了相同的选择器，相同部分会合并在一起，其他部分交替输出：

```scss
#admin .tabbar a {
  font-weight: bold;
}
#admin .overview .fakelink {
  @extend a;
}
```

编译为：

```css
#admin .tabbar a,
#admin .tabbar .overview .fakelink,
#admin .overview .tabbar .fakelink {
  font-weight: bold; }
```

#### 7.3.6 @extend-Only 选择器

Sass 引入了占位符选择器 `%` 。占位符选择器需要通过延伸指令使用，被延伸后，占位符选择器本身不会被编译。

```scss
// This ruleset won't be rendered on its own.
#context a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}
.notice {
  @extend %extreme;
}
```

编译为：

```css
#context a.notice {
  color: blue;
  font-weight: bold;
  font-size: 2em; }
```

#### 7.3.7 `!optional`声明

如果`@extend`失败会收到错误提示，比如说，`a.important {@extend .notice}`，当没有 `.notice` 选择器时，将会报错，只有 `h1.notice` 包含 `.notice` 时也会报错，因为 `h1` 与 `a` 冲突，会生成新的选择器。

如果要求`@extend`不生成新选择器，可以通过`!optional`声明来达到这个目的。

```scss
a.important {
  @extend .notice !optional;
}
```

#### 7.3.8 在指令中延伸

在指令中使用`@extend`时，Sass 不可以将指令外层的 CSS 规则延伸给指令内层的 CSS。

可以这样

```scss
@media print {
  .error {
    border: 1px #f00;
    background-color: #fdd;
  }
  .seriousError {
    @extend .error;
    border-width: 3px;
  }
}
```

不可以这样

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}

@media print {
  .seriousError {
    // INVALID EXTEND: .error is used outside of the "@media print" directive
    @extend .error;
    border-width: 3px;
  }
}
```

### 7.4 @at-root

```scss
.parent {
  ...
  @at-root .child { ... }
}
```

编译为

```css
.parent { ... }
.child { ... }
```

也可以用于一个包含多选择器的块

```scss
.parent {
  ...
  @at-root {
    .child1 { ... }
    .child2 { ... }
  }
  .step-child { ... }
}
```

编译为：

```css
.parent { ... }
.child1 { ... }
.child2 { ... }
.parent .step-child { ... }
```

默认情况下，`@at-root`并不会使指定的规则跳出指令，可以使用 `@at-root(without: ...)` ，从而达到移出指令的目的。

```scss
@media print {
  .page {
    width: 8in;
    @at-root (without: media) {
      color: red;
    }
  }
}
```

编译为

```css
@media print {
  .page {
    width: 8in;
  }
}
.page {
  color: red;
}
```

如果不使用的话，是这样的

```scss
@media print {
  .page {
    width: 8in;
    @at-root {
      color: red;
    }
  }
}
```

编译为

```css
@media print {
  .page {
    width: 8in;
  }
  color: red;
}
```

`@at-root(without: ...)` 有两个关键词 `rule` 和 `all`。默认的 `@at-root` 就是 `@at-root(without: rule)`。`@at-root(without: all)` 就是跳出所有的指令和规则。

### 7.5 @debug

`@debug` 在 Sass 中是用来调试的，当在 Sass 的源码中使用了 `@debug` 指令后，Sass 代码在编译错误的时候，在命令行会输出设置的提示 BUG。

```scss
@debug 10em + 12em;
```

输出为

```sh
Line 1 DEBUG: 22em
```

### 7.6 @warn

`@warn`指令用于提供有关问题的警告性建议。

在 `@warn` 和 `@debug` 之间有两个主要区别：

* 可以使用命令行选项 `--quiet` 或者 Sass 选项 `:quiet` 将警告关掉；
* 伴随着信息会打印一个样式表追踪，这样被警告的人就可以看到他们的样式哪里导致了警告。

使用范例：

```scss
@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @warn "Assuming #{$x} to be in pixels";
    $x: 1px * $x;
  }
  @if unitless($y) {
    @warn "Assuming #{$y} to be in pixels";
    $y: 1px * $y;
  }
  position: relative; left: $x; top: $y;
}
```

### 7.7 @error

`@error` 指令将抛出一个 SassScript 表达式的值来作为致命错误，并且包含了一个不错的堆追踪。通常被用于验证 mixins 和 functions 的参数。

```scss
@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @error "$x may not be unitless, was #{$x}.";
  }
  @if unitless($y) {
    @error "$y may not be unitless, was #{$y}.";
  }
  position: relative; left: $x; top: $y;
}
```

## 8. 控制指令

控制指令主要与混合指令 mixin 配合使用。

### 8.1 if()

内置 if() 函数从两个可能的结果返回一个结果。所述函数结果可能不能定义或进一步计算变量。

```sass
if(true, 1px, 2px) => 1px
  if(false, 1px, 2px) => 2px
```

### 8.2 @if

当 `@if` 的表达式返回值不是 `false` 或者 `null` 时，条件成立，输出 `{}` 内的代码。

```scss
p {
  @if 1 + 1 == 2 { border: 1px solid; }
  @if 5 < 3 { border: 2px dotted; }
  @if null  { border: 3px double; }
}
```

编译为

```css
p {
  border: 1px solid; }
```

`@if`声明后面可以跟多个 `@else if` 声明，或者一个 `@else` 声明。

```scss
$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
```

编译为

```css
p {
  color: green; }
```

### 8.3 @for

`@for`指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：`@for $var from <start> through <end>`，或者 `@for $var from <start> to <end>`，区别在于 `through` 与 `to` 的含义：当使用`through`时，条件范围包含`<start>` 与 `<end>` 的值，而使用 `to` 时条件范围内只包含 `<start>` 的值不包含 `<end>` 的值。另外，`$var` 可以是任何变量，`<start>` 和 `<end>` 必须是整数值。

```scss
@for $i from 1 through 3 {
  .item-#{$i} { width: 2em * $i; }
}
```

编译为

```css
.item-1 {
  width: 2em; }
.item-2 {
  width: 4em; }
.item-3 {
  width: 6em; }
```

### 8.4 @each

`@each` 指令的格式是 `$var in <list>`，`$var` 可以是任何变量名，而 `<list>` 是一连串的值，也就是值列表。

`@each` 将变量 `$var` 作用于值列表中的每一个项目，然后输出结果。

```scss
@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}
```

编译为

```css
.puma-icon {
  background-image: url('/images/puma.png'); }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png'); }
.egret-icon {
  background-image: url('/images/egret.png'); }
.salamander-icon {
  background-image: url('/images/salamander.png'); }
```

`@each` 命令也可以使用多变量。

```scss
@each $animal, $color, $cursor in (puma, black, default),
                                  (sea-slug, blue, pointer),
                                  (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}
```

编译为

```css
.puma-icon {
  background-image: url('/images/puma.png');
  border: 2px solid black;
  cursor: default; }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
  border: 2px solid blue;
  cursor: pointer; }
.egret-icon {
  background-image: url('/images/egret.png');
  border: 2px solid white;
  cursor: move; }
```

也可以使用 maps

```scss
@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}
```

编译为

```css
h1 {
  font-size: 2em; }
h2 {
  font-size: 1.5em; }
h3 {
  font-size: 1.2em; }
```

### 8.5 @while

`@while` 指令重复输出格式直到表达式返回结果为 `false`。

```scss
$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}
```

编译为

```css
.item-6 {
  width: 12em; }

.item-4 {
  width: 8em; }

.item-2 {
  width: 4em; }
```

## 9. 混合指令

混合指令用于定义可重复使用的样式，避免了使用无语义的 class。

### 9.1 定义混合指令 `@mixin`

混合指令的用法是在 `@mixin` 后添加名称与样式。

```scss
@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}
```

混合也需要包含选择器和属性，可以使用 `&` 引用父选择器

```scss
@mixin clearfix {
  display: inline-block;
  &:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
  }
  * html & { height: 1px }
}
```

### 9.2 引用混合样式 `@include`

使用 `@include` 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）

```scss
.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}
```

编译为

```css
.page-title {
  font-family: Arial;
  font-size: 20px;
  font-weight: bold;
  color: #ff0000;
  padding: 4px;
  margin-top: 10px; }
```

也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。

```scss
@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}
@include silly-links;
```

编译为

```css
a {
  color: blue;
  background-color: red; }
```

混合样式中也可以包含其他混合样式

```scss
@mixin compound {
  @include highlighted-background;
  @include header-text;
}
@mixin highlighted-background { background-color: #fc0; }
@mixin header-text { font-size: 20px; }
```

混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。

### 9.3 参数

参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号中。引用指令时，按照参数的顺序，再将所赋的值对应写进括号。

```scss
@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue, 1in); }
```

编译为

```css
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; }
```

混合指令可以给参数设置默认值

```scss
@mixin sexy-border($color, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue); }
h1 { @include sexy-border(blue, 2in); }
```

编译为

```css
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; }

h1 {
  border-color: blue;
  border-width: 2in;
  border-style: dashed; }
```

混合指令也可以使用关键词参数

```scss
p { @include sexy-border($color: blue); }
h1 { @include sexy-border($color: blue, $width: 2in); }
```

关键词参数可以打乱顺序使用，如果使用默认值也可以缺省，另外，参数名被视为变量名，下划线、短横线可以互换使用。

不确定混合指令需要使用多少个参数的时候，可以使用参数变量`...`声明（写在参数的最后方）。

```scss
@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}
.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}
```

编译为

```css
.shadowed {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}
```

参数变量也可以在引用混合指令的时候，用法和平常一样，将一串值列表中的值逐条作为参数引用。

```scss
@mixin colors($text, $background, $border) {
  color: $text;
  background-color: $background;
  border-color: $border;
}
$values: #ff0000, #00ff00, #0000ff;
.primary {
  @include colors($values...);
}
```

编译为

```css
.primary {
  color: #ff0000;
  background-color: #00ff00;
  border-color: #0000ff;
}
```

可以使用变量参数包裹一个 mixin 并且不需要改变 mixin 的参数签名就可以添加额外的样式。用这种方法，可以向被包裹的 mixin 中传递关键词参数。

```scss
@mixin wrapped-stylish-mixin($args...) {
  font-weight: bold;
  @include stylish-mixin($args...);
}
.stylish {
  // The $width argument will get passed on to "stylish-mixin" as a keyword
  @include wrapped-stylish-mixin(#00ff00, $width: 100px);
}
```

### 9.4 向混合样式中导入内容

在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 `@content` 标志的地方。

```scss
@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #logo {
    background-image: url(/logo.gif);
  }
}
```

编译为

```css
* html #logo {
  background-image: url(/logo.gif);
}
```

为了便于书写，`@mixin` 可以用 `=` 表示，而 `@include` 可以用 `+` 表示（sass 的写法）。

```scss
=apply-to-ie6-only
  * html
    @content

+apply-to-ie6-only
  #logo
    background-image: url(/logo.gif)
```

注意：当 `@content` 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。

`@content` 访问的变量是其在定义的时候的变量，而不是 mixin 的时候的。

```scss
$color: white;
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}
.colors {
  @include colors { color: $color; }
}
```

编译为

```css
.colors {
  background-color: blue;
  color: white;
  border-color: blue;
}
```

## 10. 函数指令

Sass 支持自定义函数，并能在任何属性值或 SassScript 中使用。

```scss
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }
```

编译为

```css
#sidebar {
  width: 240px; }
```

与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以包含多条语句，需要调用 `@return` 输出结果。

自定义的函数也可以使用关键词参数。

```scss
#sidebar { width: grid-width($n: 5); }
```

建议在自定义函数前面添加前缀避免命名冲突。

自定义函数与 mixin 相同，都支持 变量参数。

## 11. 输出格式

Sass 提供了四种输出格式，可以通过 `:style option` 选项设定，也可以在命令行中使用 `--style` 选项。

* `:nested` -- 嵌套
* `:expanded` -- 扩展（更类似于手写的样式）
* `:compact` -- 紧凑（每条 CSS 规则只占一行）
* `:compressed` -- 压缩

## 12. 扩展 Sass

* 自定义 Sass 函数
* 存储缓存
* 自定义导入


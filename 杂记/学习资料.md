# 一、计算机基础知识

## 大小端

### 资料

[大小端详解](https://zhuanlan.zhihu.com/p/144718837)

[什么是大小端，如何确定大小端](https://blog.csdn.net/wwwlyj123321/article/details/100066463)

### 什么是大小端

**大端**：数值的高位字节存放在内存的低地址端，低位字节放在内存的高地址端；

内存低地址 --------------------> 内存高地址

0x1A | 0x2B | 0x3C | 0x4D

高位字节 <-------------------- 低位字节

**小端**：数值的低位字节存放在内存的低地址端，高位字节放在内存的高地址端；

内存低地址 --------------------> 内存高地址

0x4D | 0x3C | 0x2B | 0x1A

低位字节 --------------------> 高位字节

大端小端是不同的字节顺序存储方式，统称为**字节序**；

**目前我们常见的CPU PowerPC、IBM是大端模式，x86是小端模式。ARM既可以工作在大端模式，也可以工作在小端模式，一般ARM都默认是小端模式。一般通讯协议都采用的是大端模式。**

### 通过C代码检测大小端

**方式1**：借助联合体 union 特性实现（**联合体类型数据所占的内存空间等于其最大的成员所占的空间，对于联合体内部所有成员的存取都是相对于该联合体基地址的偏移量为 0 处开始，即从该联合体所占内存的首地址位置开始。**）

```c
#include <stdio.h>
int main()
{
		union{
			int a; //4 bytes
			char b; //1 byte
		} data;
		
		data.a = 1; // 占 4 bytes，十六进制可表示为 0x 00 00 00 01
		
		if (1 == data.b) {
			printf("Little_Endian\n");
		} else {
			printf("Big_Endian\n");
		}
		
		return 0;
}
```

**方式2**：通过利用指针将 int 类型强制转换成 char 单字节，判断起始存储位置内容实现。

```c
#include <stdio.h>
int main()
{
		int a = 1;
		
		char *b = (char *)&a; // 相当于取了a的低地址部分
		
		if (1 == *b) {
			printf("Little_Endian!\n");
		} else {
			printf("Big_Endian!\n");
		}
		return 0;
}
```

**注意**：大小端描述的是字节之间的关系，MSB、LSB 描述的是 bit 位之间的关系。字节是存储空间的基本计量单位，所以通过高位字节和低位字节来理解大小端存储是最为直接的。

**MSB**：最高有效位，是二进制数中的最高位，代表了数值中最重要的位。

**LSB**：最低有效位，是二进制数中的最低位，代表了数值中最不重要的位。

### 三种确定大小端错误的方案

```c
// 强制类型转换
int a;
char b;
a = 1;
b = (char)a;
printf ("b = %d.\n", b);
```

```c
// 移位
int a, b;
a = 1;
b = a >> 1;
printf("b = %d.\n", b);
```

```c
// 位与
int a = 1;
int b = a & 0xff;
printf("b = %d.\n", b);
```

**位与、移位、强制类型转换等运算是编译器提供的运算，这个运算是高于内存层次的（或者说这些运算在二进制层次具有可移植性，也就是说&的时候一定是高字节&高字节，低字节&低字节，和二进制存储无关）。**
